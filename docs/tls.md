#  Transport Layer Security (TLS) Protocol

##  SSLKEYLOGFILE

From onenote

```shell
export SSLKEYLOGFILE=/Users/bulent/git-repos/temp/.ssl-key.log
open /Applications/Google\ Chrome.app --args --ssl-key-log-file=/Users/bulent/git-repos/temp/.ssl-key.log
tail -f .ssl-key.log | awk '{"date \"+%Y%m%d_%H%M%S\"" | getline now} {close("date")} {print now ": " $0}'
tail -f .ssl-debug.log | awk '{"date \"+%Y%m%d_%H%M%S\"" | getline now} {close("date")} {print now ": " $0}'
```

<https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format>

## Generating the session keys

### TLS 1.3, TLS_AES_256_GCM_SHA384,GCM

In TLS 1.3, session keys are generated using the "Encrypted Handshake Messages" (EKM) mechanism. The EKM is generated by mixing the client and server random values, the pre-master secret, and the transcript hash values of the previous handshake messages.

Here is an example of how session keys are generated using the cipher suite "TLS_AES_256_GCM_SHA384", which uses the AES-256 cipher in Galois/Counter Mode (GCM) for encryption and the SHA-384 hash algorithm for integrity verification:

1. Client and server generate random values: During the initial handshake, the client and server generate random values called the "client random" and "server random" respectively. These values are 32 bytes long and are included in the Client Hello and Server Hello messages.

2. Client sends pre-master secret: The client generates a pre-master secret, which is a random value that is encrypted using the server's public key and sent to the server in the Client Key Exchange message.

3. Master secret derivation: The server uses its private key to decrypt the pre-master secret, and both parties use a key derivation function (KDF) to generate a master secret. The KDF uses the client random, server random, and pre-master secret as input.

4. Transcript hash: Both parties maintain a transcript hash, which is a hash of all the handshake messages exchanged so far. The transcript hash is updated after each message is sent or received.

5. Key expansion: The session keys are generated by expanding the master secret using the KDF and the transcript hash. The resulting EKM is then split into multiple keys for use in encryption, authentication, and other purposes. For example, the "TLS_AES_256_GCM_SHA384" cipher suite generates a 256-bit encryption key, a 128-bit authentication key, and a 128-bit IV (Initialization Vector) for use with the AES-256 GCM cipher mode.

6. Encryption and decryption: Once the session keys have been generated, both parties can use them to encrypt and decrypt data sent over the connection. The AES-256 GCM cipher mode is used to provide both confidentiality and integrity protection for the data.

Overall, the process of generating session keys in TLS 1.3 involves a combination of random values, public-key cryptography, hashing, and key derivation. The resulting session keys are used to provide strong encryption and authentication for the data exchanged between the client and server.

##  Key expansion phase of session key generation

The key expansion phase is the final step in the process of generating session keys in TLS. During this phase, a key derivation function (KDF) is used to derive multiple keys and nonces from the shared secret generated in the previous step (i.e., the master secret).

The KDF used in TLS 1.3 is called the "TLS Key Schedule". It is a set of hash-based functions that takes the master secret, the client and server random values, and the transcript hash of the handshake messages exchanged so far, as inputs. The KDF produces a set of output values, including the following:

1. A set of encryption keys: These keys are used to encrypt and decrypt the data exchanged between the client and server. There are typically two encryption keys: one for the client to server direction, and one for the server to client direction. The length of these keys depends on the chosen cipher suite and can range from 128 to 256 bits.

2. A set of authentication keys: These keys are used to provide message authentication codes (MACs) that ensure the integrity of the data exchanged between the client and server. There are typically two authentication keys: one for the client to server direction, and one for the server to client direction. The length of these keys also depends on the chosen cipher suite and can range from 128 to 256 bits.

3. A set of nonces: These values are used to ensure that the same key is not used to encrypt two different messages. There are typically two nonces: one for the client to server direction, and one for the server to client direction. The length of these nonces depends on the chosen cipher suite and can range from 64 to 128 bits.

4. Any other keys or values required by the cipher suite: Depending on the chosen cipher suite, additional keys or values may be derived during the key expansion phase.

Once the key expansion phase is complete, the session keys are ready to be used for encryption and decryption of the data exchanged between the client and server. The keys and nonces derived during the key expansion phase are used in conjunction with the chosen cipher suite and cipher mode to provide confidentiality, integrity, and authenticity for the data.

###  TLS 1.3 Python Example

``` py title="A TLS 1.3 protected TCP Socket sending a GET Request"
{% include "tls1_3-sample1.py" %}
```
